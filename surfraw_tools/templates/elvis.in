#!/bin/sh
# elvis: {{ name }}	-- {{ description }}
# Generated-By: {{ GENERATOR_PROGRAM }}
. surfraw || exit 1

w3_usage_hook ()
{
	cat <<EOF
Usage: $w3_argv0 [options] [search words]...
Description:
  {{ description|replace('$', '\\$') }}
{% if any_options_defined %}
Local options:
{{ local_help_output }}
{% endif %}
EOF
	w3_global_usage
}

{# Only define the option parsing if any #}
{# flags, bools, enums, or aliases are defined #}
{% if any_options_defined %}
w3_config_hook ()
{
	# Bools
	{% for bool in bools %}
	defyn {{ bool.name|ns }} {{ bool.default }}
	{% else %}
	## defyn {{ 'variable'|ns }} default_yes_or_no
	{% endfor %}

	# Enums
	{% for enum in enums %}
	def {{ enum.name|ns }} {{ enum.default }}
	{% else %}
	## defyn {{ 'variable'|ns }} default_enum_value
	{% endfor %}
	{# Only show if list option defined.  Users may be confused if an undefined `__mkelvis_deflist` is shown #}
	{% if lists %}

	# Lists
	{% for list in lists %}
	__mkelvis_deflist {{ list.name|ns }} {{ list.defaults|join(',') }}
	{% else %}
	## __mkelvis_deflist {{ 'listvar'|ns }} default_val1,default_val2,default_val3
	{% endfor %}

	{% endif %}
	# 'Anythings'
	{% for anything in anythings %}
	def {{ anything.name|ns }} {{ anything.default }}
	{% else %}
	## defyn {{ 'variable'|ns }} default_anything
	{% endfor %}

	# Flags don't use any config

	# Aliases don't use any config

	# Special options
	{% for special in specials %}
	def {{ special.name|ns }} {{ special.default }}
	{% else %}
	## def {{ 'special'|ns }} $SURFRAW_special
	{% endfor %}
}
{# Only define list functions if any list enums are defined #}
{% if lists %}
__mkelvis_default_ifs=' 	
'
# Change IFS to "," and save old value for expanding lists properly.
__mkelvis_enter_list_ctx ()
{
	test -n "$__mkelvis_old_ifs" && err "tried to enter list context but are already in one"
	__mkelvis_old_ifs="${IFS:-$__mkelvis_default_ifs}"
	IFS=,
}
__mkelvis_exit_list_ctx ()
{
	test -z "$__mkelvis_old_ifs" && err "tried to exit list context but have not entered one"
	IFS="$__mkelvis_old_ifs"
	__mkelvis_old_ifs=''
}

__mkelvis_deflist ()
{
	def "$@"
}
__mkelvis_addlist ()
{
	__mkelvis_addlist__tmp="$(eval echo \$$1)"
	if [ -z "$__mkelvis_addlist__tmp" ]; then
		__mkelvis_addlist__newlist="$2"
	else
		__mkelvis_addlist__newlist="$__mkelvis_addlist__tmp,$2"
	fi
	setopt "$1" "$__mkelvis_addlist__newlist"
}
__mkelvis_removelist ()
{
	__mkelvis_removelist__toremove_re="$(echo "$2" | sed 's/,/\\|/g')"
	__mkelvis_removelist__newlist=''

	__mkelvis_enter_list_ctx
	eval vars="$(echo \$$1)"
	for val in $vars; do
		# Add back to list if not in list of values to remove.
		if ! echo $val | grep "$__mkelvis_removelist__toremove_re" >/dev/null 2>&1; then
			__mkelvis_exit_list_ctx
			__mkelvis_addlist __mkelvis_removelist__newlist "$val"
			__mkelvis_enter_list_ctx
		fi
	done
	__mkelvis_exit_list_ctx

	# Replace old list with new list.
	__mkelvis_clearlist "$1"
	__mkelvis_deflist "$1" "$__mkelvis_removelist__newlist"
}
__mkelvis_clearlist ()
{
	eval $1=''
}
{% endif %}

{% macro _parse_option(opt, setopt='setopt') %}
{% set opts = [opt] + opt.aliases|list %}
{# All standalone, non-flag options have args #}
{# Aliases are together with their target so it doesn't matter #}
{% if opt is flag_option %}
	{% set suffix = "" %}
	{% set varname = opt.target.name %}
	{% set optarg = opt.value %}
{% else %}
	{% set suffix = "=*" %}
	{% set varname = opt.name %}
	{% set optarg = "$optarg" %}
{% endif %}
{% set ns = namespace(patterns=[]) %}
{% for name in opts|map(attribute='name')|sort %}
	{% set ns.patterns = ns.patterns + ["-" ~ name ~ suffix] %}
{% endfor %}
{% set prefix = ns.patterns|join('|') ~ ') ' ~ setopt ~ ' '  ~ varname|ns %}
{# If optarg contains whitespace or is special in any way, quote it #}
{% if optarg == '$optarg' or ' ' in optarg or '\t' in optarg or '\n' in optarg %}
{{ prefix }} "{{ optarg }}" ;;
{%- else %}
{{ prefix }} {{ optarg }} ;;
{%- endif %}
{%- endmacro %}{# _parse_option #}
{% macro _parse_options(opts, default_optname, setopt='setopt') %}
{% for opt in opts %}
{{ _parse_option(opt, setopt=setopt) }}
{% if opt.flags %}
## Start: flags for {{ opt.name|ns }}
{% for flag in opt.flags %}
{{ _parse_option(flag, setopt=setopt) }}
{% endfor %}{# opt.flags #}
## End: flags for {{ opt.name|ns }}
{% endif %}{# opt.flags #}
{% else %}
{% set suffix = "=*" %}
{% set varname = default_optname %}
##-{{ default_optname }}{{ suffix }}|-alias1{{ suffix }}|-alias2{{ suffix }}) {{ setopt }} {{ varname|ns }} "$optarg" ;;
{% endfor %}{# opts #}
{%- endmacro %}
{% macro parse_options() %}
{{ _parse_options(*varargs, **kwargs)|indent(8)|replace('    ', '\t') }}
{%- endmacro %}
w3_parse_option_hook ()
{
	opt="$1"
	optarg="$2"
	case "$opt" in
		# Bools
		{{ parse_options(bools, default_optname='bool', setopt='setoptyn') }}
		# Enums
		{{ parse_options(enums, default_optname='enum') }}
		# 'Anythings'
		{{ parse_options(anythings, default_optname='anything') }}
		# Special options
		{{ parse_options(specials, default_optname='special') }}
		*) return 1 ;;
	esac
	return 0
}
{% endif %}

w3_config
w3_parse_args "$@"

escaped_args=$(w3_url_of_arg $w3_args)

# Check enums
{% macro check_enum(var, values, orig_var=None) %}
case "${{ var }}" in
	{{ '|'.join(values) }}) ;;
	{% if orig_var is none %}
	*) err "Invalid value for {{ var }}" ;;
	{% else %}
	*) err "Invalid value for {{ orig_var }}" ;;
	{% endif %}
esac
{%- endmacro %}
{% for enum in enums %}
{{ check_enum(enum.name|ns, enum.values) }}
{% endfor %}
{% for enum_list in lists.enums %}
{# Don't spew too many unrelated things into generated elvi #}
{% if loop.first %}
# Check enum lists
## Entering list context for all the checking should be safe.
__mkelvis_enter_list_ctx
{% endif %}
for val in ${{ enum.name|ns }}; do
	{{ check_enum('val', enum.values, orig_var=enum.name|ns)|indent(4)|replace('    ', '\t') }}
done
{% if loop.last %}
__mkelvis_exit_list_ctx
{% endif %}
{% endfor %}{# lists.enums #}

# Collapse variables
{# TODO: Name this better! #}
{% for collapse in collapses %}
case "${{ collapse.variable|ns }}" in
	{% for branch in collapse.collapses %}
	{# Last in `branch` is the result #}
	{{ '|'.join(branch[:-1]) }}) {{ collapse.variable|ns }}={{ branch[-1] }} ;;
	{% endfor %}
esac
{% endfor %}

# Any variables in the url should have values now
if test -z "$w3_args"; then
	w3_browse_url "{{ base_url }}"
	exit
fi
# Map variables to parameters
search_url="{{ search_url }}"
{% for map in mappings %}
{# The first iteration is special #}
{% if loop.first %}
search_url="${search_url}{{ map.parameter|urlencode }}=${{ map.variable|ns }}"
{% else %}
search_url="$search_url&{{ map.parameter|urlencode }}=${{ map.variable|ns }}"
{% endif %}
{% else %}
## First parameter
##search_url="${search_url}param1=${{ 'variable1'|ns }}"
## Successive parameters
##search_url="$search_url&param2=${{ 'variable2'|ns }}"
{% endfor %}

# Add the search to url
{# Mappings and a query parameter are necessarily inclusive #}
{# `mkelvis` should prevent a situation where only one of the two are true #}
{% if mappings|length > 0 and query_parameter is not none %}
search_url="$search_url&{{ query_parameter|urlencode }}=$escaped_args"
{% else %}
search_url="${search_url}${escaped_args}"
{% endif %}
w3_browse_url "$search_url"
