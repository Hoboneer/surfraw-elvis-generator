# Bash completion script for standalone surfraw elvi
# Generated by {{ GENERATOR_PROGRAM }}

{# TODO: Make these macros indent correctly... #}
{% macro _complete_enum(enum, name=None) %}
# Option is in the form `opt=`
if [ "$cur" = '='  ] && [ "$prev" = '-{% if name is none %}{{ enum.name }}{% else %}{{ name }}{% endif %}' ]; then
	COMPREPLY=( {% for val in enum.values %}'{{ val }}' {% endfor %} )
	return 0
fi
# TODO: Option is in the form `opt=*`
{% endmacro %}
{% macro complete_enum() %}
{{ _complete_enum(*varargs, **kwargs)|indent|replace('    ', '\t') }}
{% endmacro %}

{% macro _complete_bool(bool) %}
# Option is in the form `opt=`
if [ "$cur" = '='  ] && [ "$prev" = '-{{ bool.name }}' ]; then
	COMPREPLY=( $(compgen -W "$yes_no_args") )
	return 0
fi
{% endmacro %}
{% macro complete_bool() %}
{{ _complete_bool(*varargs, **kwargs)|indent|replace('    ', '\t') }}
{% endmacro %}

_surfraw_{{ name }} ()
{
	COMPREPLY=()
	local cur=${COMP_WORDS[COMP_CWORD]}
	local prev=${COMP_WORDS[COMP_CWORD-1]}
	local opts='{% for opt in chain.from_iterable(options) %}-{{ opt.name }}{% if not loop.last %} {% endif %}{% endfor %}'
	local yes_no_args='yes no on off 1 0'

	# Enums
	{% for enum in enums %}
	{{ complete_enum(enum) }}
	{% endfor %}

	# Bools
	{% for bool in bools %}
	{{ complete_bool(bool) }}
	{% endfor %}

	# Aliases
	{# Only enums and bools can be reasonably completed. #}
	{% for alias in aliases %}
	{% if alias.target is enum_option %}
	# Enum
	{{ complete_enum(alias.target, name=alias.name) }}
	{% elif alias.target is bool_option %}
	# Bool
	{{ complete_bool(alias) }}
	{% endif %}
	{% endfor %}

	if [[ "$cur" =~ -[^=]* ]]; then
		COMPREPLY=( $(compgen -W "$opts" -- $cur) )
		return 0
	fi
}
## test first in case removed-but-unpurged
#type -p {{ name }} >/dev/null 2>&1 && complete -F _surfraw_{{ name }} {{ name }}
complete -F _surfraw_{{ name }} {{ name }}
