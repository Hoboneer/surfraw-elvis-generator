# Bash completion script for standalone surfraw elvi
# Generated by {{ GENERATOR_PROGRAM }}

{# TODO: Make these macros indent correctly... #}
{% macro _complete_enum(enum, name=None) %}
{% if name is none %}
{% set name = enum.name %}
{% endif %}
{# Values are specific to enums #}
local {{ enum.name }}_values='{% for val in enum.values %}{{ val }} {% endfor %}'
# Option is in the form `opt=*`
if [[ "$cur" =~ -{{ name }}=([a-z]*) ]]; then
	COMPREPLY=( $(compgen -W "${{ enum.name }}_values" "${BASH_REMATCH[1]}") )
	return 0
fi
{% endmacro %}
{% macro complete_enum() %}
{{ _complete_enum(*varargs, **kwargs)|indent|replace('    ', '\t') }}
{% endmacro %}

{%- macro _complete_bool(bool) %}
# Option is in the form `opt=*`
if [[ "$cur" =~ -{{ bool.name }}=([a-z]*) ]]; then
	COMPREPLY=( $(compgen -W "$yes_no_args" "${BASH_REMATCH[1]}") )
	return 0
fi
{% endmacro %}
{% macro complete_bool() %}
{{ _complete_bool(*varargs, **kwargs)|indent|replace('    ', '\t') }}
{% endmacro %}

_surfraw_{{ name }} ()
{
	COMPREPLY=()

	local cur prev
	_get_comp_words_by_ref -n = cur prev

	local flag_opts='{% for opt in flags %}-{{ opt.name }}{% if not loop.last%} {% endif %}{% endfor %}'
	local enum_opts='{% for opt in enums %}-{{ opt.name }}={% if not loop.last%} {% endif %}{% endfor %}'
	local bool_opts='{% for opt in bools %}-{{ opt.name }}={% if not loop.last%} {% endif %}{% endfor %}'
	local anything_opts='{% for opt in anythings %}-{{ opt.name }}={% if not loop.last%} {% endif %}{% endfor %}'
	{# Flags are the only options that shouldn't have a trailing equals displayed #}
	local alias_opts='{% for opt in aliases %}-{{ opt.name }}{% if opt.target is not flag_option %}={% endif %}{% if not loop.last%} {% endif %}{% endfor %}'
	local opts=""$flag_opts" "$enum_opts" "$bool_opts" "$anything_opts" "$alias_opts""

	local yes_no_args='yes no on off 1 0'

	# Enums
	{% for enum in enums %}
	{{ complete_enum(enum) }}
	{% endfor %}

	# Bools
	{% for bool in bools %}
	{{ complete_bool(bool) }}
	{% endfor %}

	# Aliases
	{# Only enums and bools can be reasonably completed. #}
	{% for alias in aliases %}
	{% if alias.target is enum_option %}
	# Enum
	{{ complete_enum(alias.target, name=alias.name) }}
	{% elif alias.target is bool_option %}
	# Bool
	{# TODO: Figure out if this bool alias code is correct #}
	{{ complete_bool(alias) }}
	{% endif %}
	{% endfor %}

	if [[ "$cur" =~ -[^=]* ]]; then
		COMPREPLY=( $(compgen -W "$opts" -- $cur) )
		return 0
	fi
}
## test first in case removed-but-unpurged
#type -p {{ name }} >/dev/null 2>&1 && complete -F _surfraw_{{ name }} {{ name }}
complete -F _surfraw_{{ name }} {{ name }}
