#!/usr/bin/env python3
# Copyright 2019 Gabriel Lisaca
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import sys
import os
import re
from itertools import chain
from collections import namedtuple


TEMPLATE_ELVIS = """\
#!/bin/sh
# elvis: @ELVIS_NAME@\t-- @ELVIS_DESC@
. surfraw || exit 1

w3_usage_hook () {
    cat <<EOF
Usage: $w3_argv0 [options] [search words]...
Description:
  @ELVIS_DESC@
EOF
    w3_global_usage
}

@ELVIS_OPTIONS_CODE@

w3_config
w3_parse_args "$@"
if test -z "$w3_args"; then
    w3_browse_url "@DEFAULT_URL@"
else
    escaped_args=$(w3_url_of_arg $w3_args)
    @ENUMS_CHECK@
    w3_browse_url "@SEARCH_URL@${escaped_args}"
fi
"""
# Variables to replace:
#   ELVIS_NAME
#   ELVIS_DESC
#   DEFAULT_URL
#   SEARCH_URL

# Values correspond to attributes on `args` object in `main`.
VAR_REPLACEMENTS = {
    "ELVIS_NAME": "name",
    "ELVIS_DESC": "description",
    "DEFAULT_URL": "base_url",
    "SEARCH_URL": "search_url",
}
# Add the sigils.
VAR_REPLACEMENTS = {f"@{key}@": val for key, val in VAR_REPLACEMENTS.items()}


def get_parser():
    parser = argparse.ArgumentParser(description="generate an elvis for surfraw")
    parser.add_argument("name", help="name for the elvis")
    parser.add_argument(
        "base_url",
        help="the url to show in the description and is the url opened when no search terms are passed, with no protocol",
    )
    parser.add_argument(
        "search_url",
        help="the url to append arguments to, with the query parameters opened and no protocol (automatically set to 'https')",
    )
    parser.add_argument(
        "--description",
        help="description for the elvis, excluding the domain name in parentheses",
    )
    parser.add_argument(
        "--insecure", action="store_true", help="use 'http' instead of 'https'"
    )
    # Option generation
    parser.add_argument(
        "--flag",
        "-F",
        action="append",
        default=[],
        type=parse_flag_option,
        dest="flags",
        metavar="FLAG_NAME:FLAG_TARGET:YES_OR_NO",
        help="specify a flag for the elvis",
    )
    parser.add_argument(
        "--yes-no",
        "-Y",
        action="append",
        default=[],
        type=parse_bool_option,
        dest="bool_options",
        metavar="VARIABLE_NAME:DEFAULT_YES_OR_NO",
        help="specify a yes or no option for the elvis",
    )
    parser.add_argument(
        "--arg",
        "-A",
        action="append",
        default=[],
        type=parse_enum_option,
        dest="enum_options",
        metavar="VARIABLE_NAME:DEFAULT_VALUE:VAL1,VAL2,...",
        help="specify an option with an argument from a range of values",
    )
    parser.add_argument(
        "--alias",
        action="append",
        default=[],
        type=parse_alias_option,
        dest="aliases",
        metavar="ALIAS_NAME:ALIAS_TARGET",
        help="make an alias to another defined option",
    )
    return parser


# Validity checks

# This is purposely not in the full range of shell variable names because I am
# trying to encourage a particular naming convention. That is,
# `SURFRAW_elvisname_onewordvar` is what the script would generate.
VALID_SURFRAW_VAR_NAME = re.compile("^[a-z]+$")


def is_valid_name(name):
    return VALID_SURFRAW_VAR_NAME.fullmatch(name)


# TODO: Should the yes-no option take the other forms?
# TRUE_WORDS = {"yes", "on", "1"}
# FALSE_WORDS = {"no", "off", "0"}
TRUE_WORDS = {"yes"}
FALSE_WORDS = {"no"}
BOOL_WORDS = TRUE_WORDS | FALSE_WORDS


def is_valid_bool(bool_arg):
    return bool_arg in BOOL_WORDS


# Parse errors


def insufficient_spec_parts(arg, num_required):
    raise argparse.ArgumentTypeError(
        f"option arg '{arg}' needs at least {num_required} colon-delimited parts"
    )


def invalid_name(name):
    raise argparse.ArgumentTypeError(
        f"name '{name}' is an invalid variable name for an elvis"
    )


def invalid_bool(bool_arg):
    valid_bools = ", ".join(sorted(BOOL_WORDS))
    raise argparse.ArgumentTypeError(
        f"bool '{bool_arg}' must be one of the following: {valid_bools}"
    )


# Parsers

FlagOption = namedtuple("FlagOption", ["name", "target", 'value'])


def parse_flag_option(flag_opt):
    """Check a flag option, requiring three colon-delimited parts."""
    args = flag_opt.split(":")
    num_required = 3
    if len(args) < num_required:
        insufficient_spec_parts(flag_opt, num_required)

    name, target, value, *_ = args
    if not is_valid_name(name):
        invalid_name(name)
    if not is_valid_name(target):
        invalid_name(target)
    if not is_valid_bool(value):
        invalid_bool(value)

    return FlagOption(name, target, value)


BoolOption = namedtuple("BoolOption", ["name", "default"])


def parse_bool_option(bool_opt):
    """Check a yes-no option, requiring two colon-delimited parts."""
    args = bool_opt.split(":")
    num_required = 2
    if len(args) < num_required:
        insufficient_spec_parts(bool_opt, num_required)

    name, default, *_ = args
    if not is_valid_name(name):
        invalid_name(name)
    if not is_valid_bool(default):
        invalid_bool(default)

    return BoolOption(name, default)


EnumOption = namedtuple("EnumOption", ["name", 'default', "values"])


def parse_enum_option(enum_opt):
    """Check an enum option, requiring three colon-delimited parts.

    The default value (part 2) *must* be a value in the third part.
    """
    args = enum_opt.split(":")
    num_required = 3
    if len(args) < num_required:
        insufficient_spec_parts(enum_opt, num_required)

    name, default, orig_values, *_ = args
    if not is_valid_name(name):
        invalid_name(name)
    if not is_valid_name(default):
        invalid_name(default)

    # Check validity of values.
    values = orig_values.split(",")
    for val in values:
        if not is_valid_name(val):
            invalid_name(val)

    # Ensure `default` is among `values`.
    if default not in values:
        raise argparse.ArgumentTypeError(
            f"default value '{default}' must be within '{orig_values}'"
        )

    return EnumOption(name, default, values)


AliasOption = namedtuple("AliasOption", ["name", "target"])


# NOTE: Aliases are useful since they would result in the the target and its
# aliases to be displayed together in the help output.
def parse_alias_option(alias_opt):
    """Make an alias to another option.

    NOTE: This function does *not* check whether the alias points to a valid
    option. It needs to be checked elsewhere since this does not have access to
    the parser.
    """
    args = alias_opt.split(":")
    num_required = 2
    if len(args) < num_required:
        insufficient_spec_parts(alias_opt, num_required)

    name, target, *_ = args
    if not is_valid_name(name):
        invalid_name(name)
    if not is_valid_name(target):
        invalid_name(target)

    return AliasOption(name, target)


# Taken from this stackoverflow answer:
#   https://stackoverflow.com/questions/12791997/how-do-you-do-a-simple-chmod-x-from-within-python/30463972#30463972
def make_executable(path):
    mode = os.stat(path).st_mode
    mode |= (mode & 0o444) >> 2  # copy R bits to X
    os.chmod(path, mode)


class AliasResolutionError(Exception):
    def __init__(self, alias):
        super().__init__(f"alias '{alias.name}' does not target any existing option")
        self.alias = alias


def resolve_aliases(args):
    # TODO: What to do about naming conflicts?
    # Order is important! (Why?)
    options = [*chain(args.flags, args.bool_options, args.enum_options)]
    for alias in args.aliases:
        for option in options:
            if alias.target == option.name:
                alias.target = option
                break
        else:
            raise AliasResolutionError(alias)


def make_case_statement(subject, pairs):
    CASE_EXPR = f"""\
case "${subject}" in
        REPLACE_ME
        *) err "Invalid value for {subject}" ;;
    esac"""
    case_body = []
    # NOTE: `body` is a single line!
    for matches, body in pairs:
        case_body.append(f"{'|'.join(matches)}) {body} ;;")
    return CASE_EXPR.replace("REPLACE_ME", "\n".join(case_body))


def generate_elvis(args):
    pattern = re.compile("|".join(re.escape(key) for key in VAR_REPLACEMENTS))
    elvis_program = pattern.sub(
        lambda m: getattr(args, VAR_REPLACEMENTS[m.group(0)]), TEMPLATE_ELVIS
    )

    # Add any options
    if not any(
        len(option)
        for option in chain(
            args.flags, args.bool_options, args.enum_options, args.aliases
        )
    ):
        # There is nothing to do.
        elvis_program = elvis_program.replace("@ELVIS_OPTIONS_CODE@", "")
    else:
        prefix = f"SURFRAW_{args.name}"
        # Flags
        flag_code = {"config": [], "parse": []}
        for flag in args.flags:
            # TODO: Maybe have option to set a default value for a flag (if undefined).
            # Really? What if there are no bool options to set the default?
            # XXX: Maybe every flag should have a corresponding yes-no option?
            # Flags don't use any config.
            flag_code["parse"].append(
                f"-{flag.name}) setoptyn {prefix}_{flag.target} {flag.value} ;;"
            )
        # Bools
        bool_code = {"config": [], "parse": []}
        for bool_opt in args.bool_options:
            bool_code["config"].append(
                f"defyn {prefix}_{bool_opt.name} {bool_opt.default}"
            )
            bool_code["parse"].append(
                f"-{bool_opt.name}=*) setoptyn {prefix}_{bool_opt.name} $optarg ;;"
            )
        # Enums
        enum_code = {"config": [], "parse": []}
        for enum_opt in args.enum_options:
            enum_code["config"].append(
                f"def {prefix}_{enum_opt.name} {enum_opt.default}"
            )
            enum_code["parse"].append(
                f"-{enum_opt.name}=*) setopt {prefix}_{enum_opt.name} $optarg ;;"
            )
        # Aliases
        alias_code = {"config": [], "parse": []}
        for alias_opt in args.aliases:
            # Aliases don't use config.
            if isinstance(alias_opt.target, FlagOption):
                line = f"-{alias_opt.name}) setoptyn {prefix}_{alias_opt.target.target} {alias_opt.target.value} ;;"
            elif isinstance(alias_opt.target, BoolOption):
                line = f"-{alias_opt.name}=*) setoptyn {prefix}_{alias_opt.target.name} $optarg ;;"
            elif isinstance(alias_opt.target, EnumOption):
                line = f"-{alias_opt.name}=*) setopt {prefix}_{alias_opt.target.name} $optarg ;;"
            else:
                raise RuntimeError(
                    "Alias target type unhandled! This should never have been reached. This is a bug!"
                )
            alias_code["parse"].append(line)

        # Config
        config_part = """\
w3_config_hook ()
{
    REPLACE_ME
}"""
        config_lines = []

        # Parse
        parse_part = """\
w3_parse_option_hook ()
{
    opt="$1"
    optarg="$2"
    case "$opt" in
        REPLACE_ME
        *) return 1 ;;
    esac
}"""
        parse_lines = []

        for option in (flag_code, bool_code, enum_code, alias_code):
            config_lines.extend(option["config"])
            parse_lines.extend(option["parse"])
        config_part = config_part.replace("REPLACE_ME", "\n".join(config_lines))
        parse_part = parse_part.replace("REPLACE_ME", "\n".join(parse_lines))

        options_part = f"""\
{config_part}

{parse_part}"""
        elvis_program = elvis_program.replace("@ELVIS_OPTIONS_CODE@", options_part)

        enum_checks = []
        # Now generate the enum option checking.
        for enum_opt in args.enum_options:
            enum_checks.append(
                make_case_statement(
                    f"{prefix}_{enum_opt.name}", [(enum_opt.values, "echo FILL ME IN")]
                )
            )
        elvis_program = elvis_program.replace("@ENUMS_CHECK@", "\n".join(enum_checks))

    return elvis_program


def main(args):
    """Main program to generate surfraw elvi.

    Exit codes:
        33 - Invalid alias
        99 - an internal error occurred
    """
    if args.description is None:
        args.description = f"Search {args.name} ({args.base_url})"
    else:
        args.description += f" ({args.base_url})"

    if args.insecure:
        # Is this the right term?
        url_scheme = "http"
    else:
        url_scheme = "https"

    args.base_url = f"{url_scheme}://{args.base_url}"
    args.search_url = f"{url_scheme}://{args.search_url}"

    try:
        resolve_aliases(args)
    except AliasResolutionError as e:
        print(e, file=sys.stderr)
        return 33

    # Generate the elvis.
    elvis_program = generate_elvis(args)

    try:
        with open(args.name, "w") as f:
            f.write(elvis_program)
        make_executable(args.name)
    except OSError:
        return 99
    return 0


if __name__ == "__main__":
    sys.exit(main(get_parser().parse_args()))
