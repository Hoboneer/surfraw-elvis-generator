#!/usr/bin/env python3
# Copyright 2019 Gabriel Lisaca
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import sys
import os
import re
from collections import namedtuple


TEMPLATE_ELVIS = """\
#!/bin/sh
# elvis: @ELVIS_NAME@\t-- @ELVIS_DESC@
. surfraw || exit 1

w3_usage_hook () {
    cat <<EOF
Usage: $w3_argv0 [options] [search words]...
Description:
  @ELVIS_DESC@
EOF
    w3_global_usage
}

w3_config
w3_parse_args "$@"
if test -z "$w3_args"; then
    w3_browse_url "@DEFAULT_URL@"
else
    escaped_args=$(w3_url_of_arg $w3_args)
    w3_browse_url "@SEARCH_URL@${escaped_args}"
fi
"""
# Variables to replace:
#   ELVIS_NAME
#   ELVIS_DESC
#   DEFAULT_URL
#   SEARCH_URL

# Values correspond to attributes on `args` object in `main`.
VAR_REPLACEMENTS = {
    "ELVIS_NAME": "name",
    "ELVIS_DESC": "description",
    "DEFAULT_URL": "base_url",
    "SEARCH_URL": "search_url",
}
# Add the sigils.
VAR_REPLACEMENTS = {f"@{key}@": val for key, val in VAR_REPLACEMENTS.items()}


def get_parser():
    parser = argparse.ArgumentParser(description="generate an elvis for surfraw")
    parser.add_argument("name", help="name for the elvis")
    parser.add_argument(
        "base_url",
        help="the url to show in the description and is the url opened when no search terms are passed, with no protocol",
    )
    parser.add_argument(
        "search_url",
        help="the url to append arguments to, with the query parameters opened and no protocol (automatically set to 'https')",
    )
    parser.add_argument(
        "--description",
        help="description for the elvis, excluding the domain name in parentheses",
    )
    parser.add_argument(
        "--insecure", action="store_true", help="use 'http' instead of 'https'"
    )
    # Option generation
    parser.add_argument(
        "--flag",
        "-F",
        action="append",
        type=parse_flag_option,
        dest="flags",
        metavar="FLAG_NAME:FLAG_TARGET:YES_OR_NO",
        help="specify a flag for the elvis",
    )
    parser.add_argument(
        "--yes-no",
        "-Y",
        action="append",
        type=parse_bool_option,
        dest="bool_options",
        metavar="VARIABLE_NAME:DEFAULT_YES_OR_NO",
        help="specify a yes or no option for the elvis",
    )
    parser.add_argument(
        "--arg",
        "-A",
        action="append",
        type=parse_enum_option,
        dest="enum_options",
        metavar="VARIABLE_NAME:DEFAULT_VALUE:VAL1,VAL2,...",
        help="specify an option with an argument from a range of values",
    )
    parser.add_argument(
        "--alias",
        action="append",
        type=parse_alias_option,
        dest="aliases",
        metavar="ALIAS_NAME:ALIAS_TARGET",
        help="make an alias to another defined option",
    )
    return parser


# Validity checks

# This is purposely not in the full range of shell variable names because I am
# trying to encourage a particular naming convention. That is,
# `SURFRAW_elvisname_onewordvar` is what the script would generate.
VALID_SURFRAW_VAR_NAME = re.compile("^[a-z]+$")


def is_valid_name(name):
    return VALID_SURFRAW_VAR_NAME.fullmatch(name)


# TODO: Should the yes-no option take the other forms?
# TRUE_WORDS = {"yes", "on", "1"}
# FALSE_WORDS = {"no", "off", "0"}
TRUE_WORDS = {"yes"}
FALSE_WORDS = {"no"}
BOOL_WORDS = TRUE_WORDS | FALSE_WORDS


def is_valid_bool(bool_arg):
    return bool_arg in BOOL_WORDS


# Parse errors


def insufficient_spec_parts(arg, num_required):
    raise argparse.ArgumentTypeError(
        f"option arg '{arg}' needs at least {num_required} colon-delimited parts"
    )


def invalid_name(name):
    raise argparse.ArgumentTypeError(
        f"name '{name}' is an invalid variable name for an elvis"
    )


def invalid_bool(bool_arg):
    valid_bools = ", ".join(sorted(BOOL_WORDS))
    raise argparse.ArgumentTypeError(
        f"bool '{bool_arg}' must be one of the following: {valid_bools}"
    )


# Parsers

FlagOption = namedtuple("FlagOption", ["name", "target", 'value'])


def parse_flag_option(flag_opt):
    """Check a flag option, requiring three colon-delimited parts."""
    args = flag_opt.split(":")
    num_required = 3
    if len(args) < num_required:
        insufficient_spec_parts(flag_opt, num_required)

    name, target, value, *_ = args
    if not is_valid_name(name):
        invalid_name(name)
    if not is_valid_name(target):
        invalid_name(target)
    if not is_valid_bool(value):
        invalid_bool(value)

    return FlagOption(name, target, value)


BoolOption = namedtuple("BoolOption", ["name", "default"])


def parse_bool_option(bool_opt):
    """Check a yes-no option, requiring two colon-delimited parts."""
    args = bool_opt.split(":")
    num_required = 2
    if len(args) < num_required:
        insufficient_spec_parts(bool_opt, num_required)

    name, default, *_ = args
    if not is_valid_name(name):
        invalid_name(name)
    if not is_valid_bool(default):
        invalid_bool(default)

    return BoolOption(name, default)


EnumOption = namedtuple("EnumOption", ["name", 'default', "values"])


def parse_enum_option(enum_opt):
    """Check an enum option, requiring three colon-delimited parts.

    The default value (part 2) *must* be a value in the third part.
    """
    args = enum_opt.split(":")
    num_required = 3
    if len(args) < num_required:
        insufficient_spec_parts(enum_opt, num_required)

    name, default, orig_values, *_ = args
    if not is_valid_name(name):
        invalid_name(name)
    if not is_valid_name(default):
        invalid_name(default)

    # Check validity of values.
    values = orig_values.split(",")
    for val in values:
        if not is_valid_name(val):
            invalid_name(val)

    # Ensure `default` is among `values`.
    if default not in values:
        raise argparse.ArgumentTypeError(
            f"default value '{default}' must be within '{orig_values}'"
        )

    return EnumOption(name, default, values)


AliasOption = namedtuple("AliasOption", ["name", "target"])


# NOTE: Aliases are useful since they would result in the the target and its
# aliases to be displayed together in the help output.
def parse_alias_option(alias_opt):
    """Make an alias to another option.

    NOTE: This function does *not* check whether the alias points to a valid
    option. It needs to be checked elsewhere since this does not have access to
    the parser.
    """
    args = alias_opt.split(":")
    num_required = 2
    if len(args) < num_required:
        insufficient_spec_parts(alias_opt, num_required)

    name, target, *_ = args
    if not is_valid_name(name):
        invalid_name(name)
    if not is_valid_name(target):
        invalid_name(target)

    return AliasOption(name, target)


# Taken from this stackoverflow answer:
#   https://stackoverflow.com/questions/12791997/how-do-you-do-a-simple-chmod-x-from-within-python/30463972#30463972
def make_executable(path):
    mode = os.stat(path).st_mode
    mode |= (mode & 0o444) >> 2  # copy R bits to X
    os.chmod(path, mode)


def main(args):
    """Main program to generate surfraw elvi.

    Exit codes:
        99 - an internal error occurred
    """
    if args.description is None:
        args.description = f"Search {args.name} ({args.base_url})"
    else:
        args.description += f" ({args.base_url})"

    if args.insecure:
        # Is this the right term?
        url_scheme = "http"
    else:
        url_scheme = "https"

    args.base_url = f"{url_scheme}://{args.base_url}"
    args.search_url = f"{url_scheme}://{args.search_url}"

    # Generate the elvis.
    pattern = re.compile("|".join(re.escape(key) for key in VAR_REPLACEMENTS))
    elvis_program = pattern.sub(
        lambda m: getattr(args, VAR_REPLACEMENTS[m.group(0)]), TEMPLATE_ELVIS
    )

    try:
        with open(args.name, "w") as f:
            f.write(elvis_program)
        make_executable(args.name)
    except OSError:
        return 99
    return 0


if __name__ == "__main__":
    sys.exit(main(get_parser().parse_args()))
